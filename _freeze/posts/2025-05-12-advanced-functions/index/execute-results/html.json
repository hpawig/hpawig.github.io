{
  "hash": "aae9d642916f7586f28b4ec7e7abfeca",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Advanced Function Writing\"\nauthor: \"Hannah Pawig\"\ndescription: \"Writing Functions with `{rlang}`\"\ndate: 05-09-2025\ncategories: [STAT541, Quarto, R, GitHub/Git] # self-defined categories\ndraft: false # setting this to 'false' will allow the post to be seen\nexecute:\n  echo: true\n  warning: false\n  message: false\n---\n\nIn Week 6 of STAT 541, we learned about writing functions in R. We were introduced to the `{rlang}`[^1] package (along with `{tidyverse}`, of course), which is a package that provides tools for implementing the \"tidy eval\" framework in R. \n\nIn this blog post, I work through the given function prompts below to showcase *advanced* function writing skills, mainly using the `rlang` package.\n\nThis assignment had an option to complete only one of the advanced functions and then the \"Alternative Lab 6\". I chose to complete all of the advanced functions, to challenge myself and improve my function writing skills. Below is the assignment with the question prompts from the lab, and my solutions to each of the functions in the code chunks.\n\n\n\n\n\n\n\n\n\n# Setting the Stage\n\n\n\nMy number one use case for writing functions and iteration / looping is to\nperform some exploration or modeling repeatedly for different \"tweaked\"\nversions. For example, our broad goal might be to fit a linear regression model\nto our data. However, there are often multiple choices that we have to make in\npractice:\n\n- Keep missing values or fill them in (imputation)? \n- Filter out outliers in one or more variables?\n\nWe can map these choices to **arguments** in a custom model-fitting function:\n\n- `impute`: TRUE or FALSE\n- `remove_outliers`: TRUE or FALSE\n\nA function that implements the analysis and allows for variation in these \nchoices:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_model <- function(df, impute, remove_outliers, mod) {\n    if (impute) {\n        df <- some_imputation_function(df)\n    }\n    \n    if (remove_outliers) {\n        df <- function_for_removing_outliers(df)\n    }\n    \n    lm(mod, data = df)\n}\n```\n:::\n\n\n# Helper Functions\n\n**Exercise 1:** Write a function that removes outliers in a dataset. The user\nshould be able to supply the dataset, the variables to remove outliers from, and\na threshold on the number of SDs away from the mean used to define outliers. \n*Hint 1: You will need to calculate a z-score to filter the values!*\n*Hint 2: You might want to consider specifying a default value (e.g., 3) for `sd_thresh`.*\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function that removes outliers in a dataset\n# By default, the outliers removed will be values that are larger than 3 sd's from the mean\n\n# The function should take a data frame, the variables to remove outliers from without quotes, and the sd_thresh\nremove_outliers <- function(df, y, ..., sd_thresh = 3) {\n  # Put variables in one enquosure\n  vars <- enquos(...)\n  \n## Input-check error message idea from Dr. T\n# Check if y and other variables are numeric\n  non_numeric <- df |> \n    # keep specified columns\n    dplyr::select({{ y }}, !!!vars) |> \n    map_lgl(~ !(is.numeric(.x))) |> \n    keep(identity) |>\n    names() # these are the names of the columns which are not numeric\n  \n  # Check for non-numeric columns\n\n  if (length(non_numeric) > 0) {\n    stop(\"\\nAll columns must be a numeric variable.\\nThe following columns are not numeric: \",\n         str_c(non_numeric, collapse = \", \"))\n  }  \n  \n  # calculate z scores within columns and determine if within threshold\n  # sum the booleans for each row. if is_outlier > 0 then it is an outlier for at least 1 var\n  df |> \n    dplyr::mutate(is_outlier = rowSums(across(.cols = c({{ y }}, !!!vars ),\n                                       ~ abs(. - mean(.)) / sd(.)) > sd_thresh))  |> \n    # only keep rows with is_outlier == F\n    dplyr::filter(is_outlier == 0) |>\n    # remove is_outlier column\n    dplyr::select(-is_outlier)\n\n\n}\n\n## references for this function:\n# https://rlang.r-lib.org/reference/splice-operator.html\n# https://rlang.r-lib.org/reference/dyn-dots.html\n# https://rlang.r-lib.org/reference/topic-quosure.html\n```\n:::\n\n\n## Testing Your Function! \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Testing how your function handles multiple input variables\nremove_outliers(diamonds, \n                price, \n                x, \n                y, \n                z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 52,689 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ℹ 52,679 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n## Testing how your function handles an input that isn't numeric\nremove_outliers(diamonds, \n                price, \n                color)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in remove_outliers(diamonds, price, color): \nAll columns must be a numeric variable.\nThe following columns are not numeric: color\n```\n\n\n:::\n\n```{.r .cell-code}\n## Testing how your function handles a non-default sd_thresh\nremove_outliers(diamonds, \n                price,\n                x, \n                y, \n                z, \n                sd_thresh = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 50,099 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ℹ 50,089 more rows\n```\n\n\n:::\n:::\n\n\n**Exercise 2:** Write a function that imputes missing values for numeric \nvariables in a dataset. The user should be able to supply the dataset, the \nvariables to impute values for, and a function to use when imputing. \n*Hint 1: You will need to use `across()` to apply your function, since the user can input multiple variables.*\n*Hint 2: The `replace_na()` function is helpful here!*\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function that imputes missing values in a dataset\n# By default, the imputation function will be the mean\n# The function should take a data frame, the variables to impute from without quotes, and the impute_fun\nimpute_missing <- function(df, y, ..., impute_fun = mean) {\n  # Put variables in one enquosure\n  vars <- enquos(...)\n\n\n# Check if y and other variables are numeric\n  non_numeric <- df |> \n    # keep specified columns\n    dplyr::select({{ y }}, !!!vars) |> \n    map_lgl(~ !(is.numeric(.x))) |> \n    keep(identity) |>\n    names() # these are the names of the columns which are not numeric\n  \n  # Check for non-numeric columns\n\n  if (length(non_numeric) > 0) {\n    stop(\"\\nAll columns must be a numeric variable.\\nThe following columns are not numeric: \",\n         str_c(non_numeric, collapse = \", \"))\n  }  \n  \n  df |> \n    # Calculate desired stat (mean by default) within columns and replace na's with stat\n    dplyr::mutate(across(.cols = c({{ y }}, !!!vars),\n                         ~ replace_na(.x, impute_fun(.x)))) \n}\n```\n:::\n\n\n## Testing Your Function! \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Testing how your function handles multiple input variables\nimpute_missing(nycflights13::flights, \n               arr_delay, \n               dep_delay)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n## Testing how your function handles an input that isn't numeric\nimpute_missing(nycflights13::flights, \n               arr_delay, \n               carrier) \n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in impute_missing(nycflights13::flights, arr_delay, carrier): \nAll columns must be a numeric variable.\nThe following columns are not numeric: carrier\n```\n\n\n:::\n\n```{.r .cell-code}\n## Testing how your function handles a non-default impute_fun\nimpute_missing(nycflights13::flights, \n               arr_delay, \n               dep_delay, \n               impute_fun = median)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n# Primary Function\n\n**Exercise 3:** Write a `fit_model()` function that fits a specified linear\nregression model for a specified dataset. The function should:\n\n- allow the user to specify if outliers should be removed (`TRUE` or `FALSE`)\n- allow the user to specify if missing observations should be imputed\n(`TRUE` or `FALSE`)\n\nIf either option is `TRUE`, your function should call your `remove_outliers()`\nor `impute_missing()` functions to modify the data **before** the regression \nmodel is fit. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function that fits a linear regression model to a dataset\n# The function should take a data frame, the formula for the model,\n# and the impute and remove_outliers arguments\n\nfit_model <- function(df, mod_formula, remove_outliers = FALSE, impute_missing = FALSE, \n                      print_inputs = FALSE, ...) {\n  \n  # Check if mod_formula is complete\n  if (!rlang::is_formula(mod_formula, lhs = TRUE)) {\n    stop(\"`mod_formula` must be a valid formula. Check LHS and RHS!\")\n  }\n  \n  # Remove outliers if specified\n  if (remove_outliers) {\n    df <- remove_outliers(df, ...)\n  }\n  \n  # Impute missing values if specified\n  if (impute_missing) {\n    df <- impute_missing(df, ...)\n  }\n  \n  # Store Inputs in a list\n  # For printing purposes\n  \n  inputs <- list(df = df,\n            mod_formula = mod_formula, \n            remove_outliers = remove_outliers, \n            impute_missing = impute_missing)\n\n  \n  # Print inputs for user to see\n  # This is optional -- default is FALSE\n  if (print_inputs) {\n    print(\"Inputs:\")\n    print(inputs)\n  }\n  \n\n  # Fit the linear regression model after removing and/or imputing values\n  df |>\n    lm(formula = (mod_formula))\n  \n\n \n}\n```\n:::\n\n\n## Testing Your Function! \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_model(\n  diamonds,\n  mod_formula = price ~ carat + cut,\n  remove_outliers = TRUE,\n  impute_missing = TRUE,\n  print_inputs = TRUE,\n  price, \n  carat\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Inputs:\"\n$df\n# A tibble: 52,527 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ℹ 52,517 more rows\n\n$mod_formula\nprice ~ carat + cut\n\n$remove_outliers\n[1] TRUE\n\n$impute_missing\n[1] TRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = (mod_formula), data = df)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n   -2460.16      7526.96      1059.65      -410.54       295.80        82.62  \n```\n\n\n:::\n\n```{.r .cell-code}\n## Test my fit_model() with an invalid mod_formula\n\nfit_model(\n  diamonds,\n  mod_formula =  ~ carat + cut,\n  remove_outliers = TRUE,\n  impute_missing = TRUE,\n  price, \n  carat\n)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in fit_model(diamonds, mod_formula = ~carat + cut, remove_outliers = TRUE, : `mod_formula` must be a valid formula. Check LHS and RHS!\n```\n\n\n:::\n:::\n\n\n\n\n# Iteration\n\nIn the `diamonds` dataset, we want to understand the relationship between\n`price` and size (`carat`). We want to explore variation along two choices:\n\n1. The variables included in the model. We'll explore 3 sets of variables:\n    - No further variables (just `price` and `carat`)\n    - Adjusting for `cut`\n    - Adjusting for `cut` and `clarity`\n    - Adjusting for `cut`, `clarity`, and `color`\n\n2. Whether or not to impute missing values\n\n3. Whether or not to remove outliers in the `carat` variable (we'll define\noutliers as cases whose `carat` is over 3 SDs away from the mean).\n\n## Parameters\n\nFirst, we need to define the set of parameters we want to iterate the\n`fit_model()` function over. The `tidyr` package has a useful function called\n`crossing()` that is useful for generating argument combinations. For each\nargument, we specify all possible values for that argument and `crossing()` \ngenerates all combinations. \n*Note that you can create a list of formula objects in R with `c(y ~ x1, y ~ x1 + x2)`.*\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_arg_combos <- tidyr::crossing(\n    impute = c(TRUE, FALSE),\n    remove_outliers = c(TRUE, FALSE), \n    mod = c(y ~ x1, \n            y ~ x1 + x2)\n)\ndf_arg_combos \n```\n:::\n\n\n**Exercise 4:** Use `crossing()` to create the data frame of argument\ncombinations for our analyses. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# function to create the data frame of argument combinations\n df_arg_combos <- tidyr::crossing(\n    impute = c(TRUE, FALSE),\n    remove_outliers = c(TRUE, FALSE), \n    mod_formula = c(price ~ carat, \n            price ~ carat + cut,\n            price ~ carat + cut + clarity,\n            price ~ carat + cut + clarity + color)\n  )\n\ndf_arg_combos |> \n  # create a mod_formula string to display\n  dplyr::mutate(mod_formula = as.character(mod_formula))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 3\n   impute remove_outliers mod_formula                          \n   <lgl>  <lgl>           <chr>                                \n 1 FALSE  FALSE           price ~ carat                        \n 2 FALSE  FALSE           price ~ carat + cut                  \n 3 FALSE  FALSE           price ~ carat + cut + clarity        \n 4 FALSE  FALSE           price ~ carat + cut + clarity + color\n 5 FALSE  TRUE            price ~ carat                        \n 6 FALSE  TRUE            price ~ carat + cut                  \n 7 FALSE  TRUE            price ~ carat + cut + clarity        \n 8 FALSE  TRUE            price ~ carat + cut + clarity + color\n 9 TRUE   FALSE           price ~ carat                        \n10 TRUE   FALSE           price ~ carat + cut                  \n11 TRUE   FALSE           price ~ carat + cut + clarity        \n12 TRUE   FALSE           price ~ carat + cut + clarity + color\n13 TRUE   TRUE            price ~ carat                        \n14 TRUE   TRUE            price ~ carat + cut                  \n15 TRUE   TRUE            price ~ carat + cut + clarity        \n16 TRUE   TRUE            price ~ carat + cut + clarity + color\n```\n\n\n:::\n:::\n\n\n## Iterating Over the Parameters\n\nWe've arrived at the final step! \n\n**Exercise 5:** Use `pmap()` from `purrr` to apply the `fit_model()` function to\nevery combination of arguments from `diamonds.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use pmap to apply the fit_model function to each row of df_arg_combos\npurrr::pmap(\n  .l = list(df = c(rep(x = list(diamonds),\n                       times = nrow(df_arg_combos))), # need a copy of df for each row\n            mod_formula = df_arg_combos$mod_formula, \n            remove_outliers = df_arg_combos$remove_outliers, \n            impute_missing = df_arg_combos$impute),\n  .f = fit_model\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n\nCall:\nlm(formula = (mod_formula), data = df)\n\nCoefficients:\n(Intercept)        carat  \n      -2256         7756  \n\n\n[[2]]\n\nCall:\nlm(formula = (mod_formula), data = df)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n   -2701.38      7871.08      1239.80      -528.60       367.91        74.59  \n\n\n[[3]]\n\nCall:\nlm(formula = (mod_formula), data = df)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3187.540     8472.026      713.804     -334.503      188.482        1.663  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   4011.681    -1821.922      917.658     -430.047      257.141       26.909  \n  clarity^7  \n    186.742  \n\n\n[[4]]\n\nCall:\nlm(formula = (mod_formula), data = df)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3710.603     8886.129      698.907     -327.686      180.565       -1.207  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   4217.535    -1832.406      923.273     -361.995      216.616        2.105  \n  clarity^7      color.L      color.Q      color.C      color^4      color^5  \n    110.340    -1910.288     -627.954     -171.960       21.678      -85.943  \n    color^6  \n    -49.986  \n\n\n[[5]]\n\nCall:\nlm(formula = (mod_formula), data = df)\n\nCoefficients:\n(Intercept)        carat  \n      -2256         7756  \n\n\n[[6]]\n\nCall:\nlm(formula = (mod_formula), data = df)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n   -2701.38      7871.08      1239.80      -528.60       367.91        74.59  \n\n\n[[7]]\n\nCall:\nlm(formula = (mod_formula), data = df)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3187.540     8472.026      713.804     -334.503      188.482        1.663  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   4011.681    -1821.922      917.658     -430.047      257.141       26.909  \n  clarity^7  \n    186.742  \n\n\n[[8]]\n\nCall:\nlm(formula = (mod_formula), data = df)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3710.603     8886.129      698.907     -327.686      180.565       -1.207  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   4217.535    -1832.406      923.273     -361.995      216.616        2.105  \n  clarity^7      color.L      color.Q      color.C      color^4      color^5  \n    110.340    -1910.288     -627.954     -171.960       21.678      -85.943  \n    color^6  \n    -49.986  \n\n\n[[9]]\n\nCall:\nlm(formula = (mod_formula), data = df)\n\nCoefficients:\n(Intercept)        carat  \n      -2256         7756  \n\n\n[[10]]\n\nCall:\nlm(formula = (mod_formula), data = df)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n   -2701.38      7871.08      1239.80      -528.60       367.91        74.59  \n\n\n[[11]]\n\nCall:\nlm(formula = (mod_formula), data = df)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3187.540     8472.026      713.804     -334.503      188.482        1.663  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   4011.681    -1821.922      917.658     -430.047      257.141       26.909  \n  clarity^7  \n    186.742  \n\n\n[[12]]\n\nCall:\nlm(formula = (mod_formula), data = df)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3710.603     8886.129      698.907     -327.686      180.565       -1.207  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   4217.535    -1832.406      923.273     -361.995      216.616        2.105  \n  clarity^7      color.L      color.Q      color.C      color^4      color^5  \n    110.340    -1910.288     -627.954     -171.960       21.678      -85.943  \n    color^6  \n    -49.986  \n\n\n[[13]]\n\nCall:\nlm(formula = (mod_formula), data = df)\n\nCoefficients:\n(Intercept)        carat  \n      -2256         7756  \n\n\n[[14]]\n\nCall:\nlm(formula = (mod_formula), data = df)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n   -2701.38      7871.08      1239.80      -528.60       367.91        74.59  \n\n\n[[15]]\n\nCall:\nlm(formula = (mod_formula), data = df)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3187.540     8472.026      713.804     -334.503      188.482        1.663  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   4011.681    -1821.922      917.658     -430.047      257.141       26.909  \n  clarity^7  \n    186.742  \n\n\n[[16]]\n\nCall:\nlm(formula = (mod_formula), data = df)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3710.603     8886.129      698.907     -327.686      180.565       -1.207  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   4217.535    -1832.406      923.273     -361.995      216.616        2.105  \n  clarity^7      color.L      color.Q      color.C      color^4      color^5  \n    110.340    -1910.288     -627.954     -171.960       21.678      -85.943  \n    color^6  \n    -49.986  \n```\n\n\n:::\n:::\n\n\n\n[^1]: Official `rlang` documentation can be found [here](https://rlang.r-lib.org)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}